<h1 id='avoid-error-of-duplicate-group_keys'>Avoid error of duplicate group_keys</h1><h3 id='prerequites-how-to-get-unique-group_keys'>Prerequites: how to get unique group_keys</h3><div class="highlight"><pre class="highlight plaintext"><code>+------------+----+--------------+--------+-----------+
| dates      | rn | rn_by_status | status | group_key |
+------------+----+--------------+--------+-----------+
| 2023-03-01 |  1 |            1 |      0 |         0 | (1st instance of status=0)
| 2023-03-02 |  2 |            2 |      0 |         0 |
| 2023-03-03 |  3 |            3 |      0 |         0 |
| 2023-03-04 |  4 |            1 |      1 |         3 | (1st instance of status=1)
| 2023-03-05 |  5 |            2 |      1 |         3 |
| 2023-03-06 |  6 |            4 |      0 |         2 | (4th instance of status=0)
| 2023-03-07 |  7 |            5 |      0 |         2 |
| 2023-03-08 |  8 |            4 |      1 |         4 |
| 2023-03-09 |  9 |            5 |      1 |         4 |
| 2023-03-10 | 10 |            6 |      1 |         4 |
+------------+----+--------------+--------+-----------+
</code></pre></div>
<p>We must first understand how consecutive data points work in conjunction with the <code>DENSE_RANK()</code> function. When consecutive data points (e.g. consecutive dates) increment step by step with the index column <code>rn</code>, it returns a unique <code>group_key</code> for that series of consecutive rows.</p>

<p>Looking at the last 3 row from the example table. When we subtract <code>rn_by_status</code> from <code>rn</code> and there is a consecutive sequence (8 minus 4, 9 minus 5, 10 minus 6) we get the same <code>group_key=4</code>. </p>
<h2 id='how-can-there-by-duplicate-groups'>How can there by duplicate groups</h2>
<blockquote>
<p>Example of unintended duplicate groups</p>
</blockquote>
<div class="highlight"><pre class="highlight plaintext"><code>+------------+----+--------------+--------+-----------+-------------------+
| dates      | rn | rn_by_status | status | group_key | correct_group_key |
+------------+----+--------------+--------+-----------+-------------------+
| 2023-03-01 |  1 |            1 |      0 |         0 |                 0 |
| 2023-03-02 |  2 | ---------- 1 | ---- 1 | ------- 1 | -------------- 11 |
| 2023-03-03 |  3 | ---------- 2 | ---- 0 | ------- 1 | -------------- 10 |
| 2023-03-04 |  4 | ---------- 3 | ---- 0 | ------- 1 | -------------- 10 |
| 2023-03-05 |  5 |            2 |      1 |         3 |                31 |
| 2023-03-06 |  6 |            3 |      1 |         3 |                31 |
| 2023-03-07 |  7 |            4 |      1 |         3 |                31 |
| 2023-03-08 |  8 |            4 |      0 |         4 |                40 |
| 2023-03-09 |  9 |            5 |      0 |         4 |                40 |
| 2023-03-10 | 10 |            6 |      1 |         4 |                41 |
+------------+----+--------------+------ -+-----------+-------------------+
</code></pre></div>
<p>By subtracting <code>rn_by_status</code> from <code>rn</code>, the <code>group_key</code> should be unique to the island and group. This should work in most situations. </p>

<p>Whoever, by random change, the order of the data may cause duplicate <code>group_keys</code>.</p>
<h2 id='best-practice-to-avoid-duplicate-group_keys'>Best practice to avoid duplicate group_keys</h2><div class="highlight"><pre class="highlight sql tab-sql"><code><span class="n">status</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="p">(...)</span> <span class="k">AS</span> <span class="n">group_key</span>
</code></pre></div>
<p>To fix this, append the status column to your <code>correct_group_key</code>. Eeliang suggest adding the main identifier (<code>status</code> or <code>user_id</code>) in the ones place. This ensures that we always know where to identify the status.</p>

<p>References:</p>

<ul>
<li><a href="https://binhhoang.io/blog/gaps-and-islands/">Resolving duplicate group_keys</a></li>
</ul>
