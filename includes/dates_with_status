<h1 id='date-column-with-status'>Date column with Status</h1>
<blockquote>
<p>Sample data</p>
</blockquote>
<div class="highlight"><pre class="highlight sql tab-sql"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="n">park_visitors</span> <span class="p">(</span>
  <span class="n">dates</span> <span class="nb">date</span> <span class="k">NOT</span>  <span class="k">NULL</span><span class="p">,</span>
  <span class="n">visitors</span> <span class="nb">integer</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">park_visitors</span> <span class="k">VALUES</span> 
<span class="p">(</span><span class="s1">'2023-03-01'</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-02'</span><span class="p">,</span> <span class="mi">109</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-03'</span><span class="p">,</span> <span class="mi">89</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-04'</span><span class="p">,</span> <span class="mi">76</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-05'</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-06'</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-07'</span><span class="p">,</span> <span class="mi">1455</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-08'</span><span class="p">,</span> <span class="mi">54</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-09'</span><span class="p">,</span> <span class="mi">98</span><span class="p">);</span>
</code></pre></div>
<p>In this version, there are 2 columns. The rows are not guaranteed to be in sequence, but is guaranteed to contain all consecutive days.</p>

<p>Table <strong>park_visitors</strong> contains 2 columns: <code>date</code>, and <code>visitors</code>. This table records the number of visitors every day, recording 0 if there are no visitors.</p>

<p>References: </p>

<ul>
<li><a href="https://towardsdatascience.com/gaps-and-islands-with-mysql-b407040d133d">Analyzing total downtime of a IoT device</a>.</li>
</ul>
<h2 id='task-objective-group-by-status-count-sequence_length'>Task objective: Group by status, count sequence_length</h2>
<blockquote>
<p>Desired output</p>
</blockquote>
<div class="highlight"><pre class="highlight markdown"><code>+------------+------------+-----------+--------+-----------------+
| start_date | end_date   | group_key | status | sequence_length |
+------------+------------+-----------+--------+-----------------+
| 2023-03-01 | 2023-03-01 |         0 |      0 |               1 |
| 2023-03-02 | 2023-03-02 |        11 |      1 |               1 |
| 2023-03-03 | 2023-03-04 |        10 |      0 |               2 |
| 2023-03-05 | 2023-03-07 |        31 |      1 |               3 |
| 2023-03-08 | 2023-03-09 |        40 |      0 |               2 |
+------------+------------+-----------+--------+-----------------+
</code></pre></div>
<p>The goal of this challenge is to find the (1) consecutive days where there are more than <100> tourist and (2) the gaps between these busy days. </p>

<p>The goal of this series of challenges is to work with a continuous stream (dates or incremental counters) and identifying <strong>islands</strong> (overlaps or consecutive rows) and <strong>gaps</strong> (missing values or null values). </p>

<aside class="success">
Note, the <strong>gaps</strong> are represented AS <code>status=0</code>.
</aside>
<h2 id='solution-rank-with-partition-by-status'>Solution: rank() with partition by status</h2><div class="highlight"><pre class="highlight sql tab-sql"><code><span class="k">WITH</span>
<span class="n">classify_into_status</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> 
    <span class="n">dates</span><span class="p">,</span> 
    <span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">visitors</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="k">THEN</span> <span class="mi">1</span> <span class="k">ELSE</span> <span class="mi">0</span> <span class="k">END</span> <span class="k">AS</span> <span class="n">status</span>
  <span class="k">FROM</span> <span class="n">park_visitors</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">dates</span>
<span class="p">),</span>
<span class="n">sort_and_rank</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> 
    <span class="n">s</span><span class="p">.</span><span class="o">*</span><span class="p">,</span>
    <span class="n">DENSE_RANK</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">dates</span><span class="p">)</span> <span class="k">AS</span> <span class="n">rn</span><span class="p">,</span>
    <span class="n">DENSE_RANK</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">status</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">dates</span><span class="p">)</span> <span class="k">AS</span> <span class="n">rn_by_status</span>
  <span class="k">FROM</span> <span class="n">classify_into_status</span> <span class="n">s</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">dates</span>
<span class="p">),</span>
<span class="n">consecutive_dates_will_share_group_key</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> 
    <span class="n">r</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> 
    <span class="n">status</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="p">(</span><span class="n">rn</span><span class="o">-</span><span class="n">rn_by_status</span><span class="p">)</span> <span class="k">AS</span> <span class="n">group_key</span>
  <span class="k">FROM</span> <span class="n">sort_and_rank</span> <span class="n">r</span>
<span class="p">),</span>
<span class="n">final_output</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> 
    <span class="k">MIN</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span> <span class="k">AS</span> <span class="n">start_date</span><span class="p">,</span> 
    <span class="k">MAX</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span> <span class="k">AS</span> <span class="n">end_date</span><span class="p">,</span> 
    <span class="n">group_key</span><span class="p">,</span> 
    <span class="n">status</span><span class="p">,</span> 
    <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sequence_length</span>
  <span class="k">FROM</span> <span class="n">consecutive_dates_will_share_group_key</span>
  <span class="k">WHERE</span> <span class="n">status</span> <span class="k">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">group_key</span><span class="p">,</span> <span class="n">status</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span>
<span class="p">)</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">final_output</span>
<span class="k">WHERE</span> <span class="n">sequence_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>
<p>Go through step by step.</p>
<h3 id='classify_into_status'><code>classify_into_status</code></h3>
<p>Band the number columns into discrete statuses.</p>
<h3 id='sort_and_rank'><code>sort_and_rank</code></h3>
<p>This CTE orders the table by the <code>dates</code> column. We create an index column <code>rn</code> and a separate rank column <code>rn_by_status</code> for each status.</p>
<h3 id='consecutive_dates_will_share_group_key'><code>consecutive_dates_will_share_group_key</code></h3>
<p>Subtracting <code>rn_by_status</code> FROM <code>rn</code> will return the same <code>group_key</code> if there are consecutive rows. Because the <code>rn_by_status</code> column increments at the same pace AS the <code>rn</code> column. This allows us to have a <code>group_key</code> for each island.</p>

<aside class="notice">
There may be rare instance where the <code>group_key</code> is  duplicated across statuses. See <a href="#avoid-error-of-overalapping-groups">how to address this issue</a>.
</aside>
<h3 id='final_output'><code>final_output</code></h3>
<p>Using the <code>group_key</code>, find the min(), max(), and count().</p>
<h3 id='example-scenarios-dates-with-status'>Example scenarios: dates with status</h3>
<p>Examples include logging downtime of a system.</p>
