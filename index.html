
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        <meta
            name="description"
            content="Documentation for the Kittn API"
        >
    <title>Gaps and Islands</title>

    <style media="screen">
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cpf {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s, .highlight .sa, .highlight .dl {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf, .highlight .fm {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv, .highlight .vm {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .nl {
  color: #f92672;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <style media="print">
      * {
        -webkit-transition:none!important;
        transition:none!important;
      }
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #586e75;
}
.highlight .err {
  color: #002b36;
  background-color: #dc322f;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cm, .highlight .cpf, .highlight .c1, .highlight .cs {
  color: #657b83;
}
.highlight .cp {
  color: #b58900;
}
.highlight .nt {
  color: #b58900;
}
.highlight .o, .highlight .ow {
  color: #93a1a1;
}
.highlight .p, .highlight .pi {
  color: #93a1a1;
}
.highlight .gi {
  color: #859900;
}
.highlight .gd {
  color: #dc322f;
}
.highlight .gh {
  color: #268bd2;
  background-color: #002b36;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #6c71c4;
}
.highlight .kc {
  color: #cb4b16;
}
.highlight .kt {
  color: #cb4b16;
}
.highlight .kd {
  color: #cb4b16;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .dl, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #859900;
}
.highlight .sa {
  color: #6c71c4;
}
.highlight .sr {
  color: #2aa198;
}
.highlight .si {
  color: #d33682;
}
.highlight .se {
  color: #d33682;
}
.highlight .nn {
  color: #b58900;
}
.highlight .nc {
  color: #b58900;
}
.highlight .no {
  color: #b58900;
}
.highlight .na {
  color: #268bd2;
}
.highlight .m, .highlight .mb, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mx {
  color: #859900;
}
.highlight .ss {
  color: #859900;
}
    </style>
    <link href="stylesheets/screen-adfb7be4.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print-966d6edc.css" rel="stylesheet" media="print" />
      <script src="javascripts/all-b12a2749.js"></script>

    <script>
      $(function() { setupCodeCopy(); });
    </script>
  </head>

  <body class="index" data-languages="[&quot;sql&quot;,&quot;markdown&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar-cad8cdcb.png" alt="" />
      </span>
    </a>
    <div class="toc-wrapper">
      <img src="images/logo-1e815a84.png" class="logo" alt="" />
        <div class="lang-selector">
              <a href="#" data-language-name="sql">sql</a>
              <a href="#" data-language-name="markdown">markdown</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <ul id="toc" class="toc-list-h1">
          <li>
            <a href="#gaps-and-island-problem" class="toc-h1 toc-link" data-title="Gaps and Island problem">Gaps and Island problem</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#challenge-objectives" class="toc-h3 toc-link" data-title="Challenge objectives">Challenge objectives</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#date-column-with-status" class="toc-h1 toc-link" data-title="Date column with Status">Date column with Status</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#task-objective-group-by-status-count-sequence_length" class="toc-h2 toc-link" data-title="Task objective: Group by status, count sequence_length">Task objective: Group by status, count sequence_length</a>
                  </li>
                  <li>
                    <a href="#solution-rank-with-partition-by-status" class="toc-h2 toc-link" data-title="Solution: rank() with partition by status">Solution: rank() with partition by status</a>
                      <ul class="toc-list-h3">
                          <li>
                            <a href="#classify_into_status" class="toc-h3 toc-link" data-title="classify_into_status"><code>classify_into_status</code></a>
                          </li>
                          <li>
                            <a href="#sort_and_rank" class="toc-h3 toc-link" data-title="sort_and_rank"><code>sort_and_rank</code></a>
                          </li>
                          <li>
                            <a href="#consecutive_dates_will_share_group_key" class="toc-h3 toc-link" data-title="consecutive_dates_will_share_group_key"><code>consecutive_dates_will_share_group_key</code></a>
                          </li>
                          <li>
                            <a href="#final_output" class="toc-h3 toc-link" data-title="final_output"><code>final_output</code></a>
                          </li>
                          <li>
                            <a href="#example-scenarios-dates-with-status" class="toc-h3 toc-link" data-title="Example scenarios: dates with status">Example scenarios: dates with status</a>
                          </li>
                      </ul>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#single-column" class="toc-h1 toc-link" data-title="Single column">Single column</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#task-objective-split-gap-and-island-count-sequence_length" class="toc-h2 toc-link" data-title="Task objective: Split gap and island, count sequence_length">Task objective: Split gap and island, count sequence_length</a>
                  </li>
                  <li>
                    <a href="#solution-calculate-gaps-and-island-separately" class="toc-h2 toc-link" data-title="Solution: calculate Gaps and Island separately">Solution: calculate Gaps and Island separately</a>
                      <ul class="toc-list-h3">
                          <li>
                            <a href="#island_details" class="toc-h3 toc-link" data-title="island_details"><code>island_details</code></a>
                          </li>
                          <li>
                            <a href="#gap_details" class="toc-h3 toc-link" data-title="gap_details"><code>gap_details</code></a>
                          </li>
                          <li>
                            <a href="#final_output" class="toc-h3 toc-link" data-title="final_output"><code>final_output</code></a>
                          </li>
                      </ul>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#range-with-status" class="toc-h1 toc-link" data-title="Range with status">Range with status</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#task-objective-group-ranges-that-overlap" class="toc-h2 toc-link" data-title="Task objective: Group ranges that overlap">Task objective: Group ranges that overlap</a>
                  </li>
                  <li>
                    <a href="#solution" class="toc-h2 toc-link" data-title="Solution">Solution</a>
                      <ul class="toc-list-h3">
                          <li>
                            <a href="#last_return_date" class="toc-h3 toc-link" data-title="last_return_date"><code>last_return_date</code></a>
                          </li>
                          <li>
                            <a href="#start_of_island-as" class="toc-h3 toc-link" data-title="start_of_island as ("><code>start_of_island as (</code></a>
                          </li>
                          <li>
                            <a href="#islands_will_share_group_key" class="toc-h3 toc-link" data-title="islands_will_share_group_key"><code>islands_will_share_group_key</code></a>
                          </li>
                          <li>
                            <a href="#consolidated_range_for_each_group" class="toc-h3 toc-link" data-title="consolidated_range_for_each_group"><code>consolidated_range_for_each_group</code></a>
                          </li>
                      </ul>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#avoid-error-of-overalapping-groups" class="toc-h1 toc-link" data-title="Avoid error of overalapping groups">Avoid error of overalapping groups</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#best-practice-to-avoid-duplicate-group_keys" class="toc-h2 toc-link" data-title="Best practice to avoid duplicate group_keys">Best practice to avoid duplicate group_keys</a>
                  </li>
              </ul>
          </li>
      </ul>
        <ul class="toc-footer">
            <li><a href='https:eeliang.github.io/python-help'>Eeliang's Python help</a></li>
            <li><a href'https://www.hackerrank.com/contests/crescent-practice-3rd-years/challenges/islands-1'>Try out the test questions at Hackerone</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id='gaps-and-island-problem'>Gaps and Island problem</h1>
<p>Hello reader!</p>

<p>I faced much difficulty when first encountering the <a href="https://livebook.manning.com/book/sql-server-mvp-deep-dives/chapter-5/">gaps and island problem</a>. Along with it&#39;s many variations and solution, it was tough to understand and tackle this problem.</p>

<p>So here is my take on the Gaps and Island problem (Eeliang style.)</p>
<h3 id='challenge-objectives'>Challenge objectives</h3>
<p>The goal of this series of challenges is to work with a continuous stream (dates or incremental counters) and identifying <strong>islands</strong> (overlaps or consecutive rows) and <strong>gaps</strong> (missing values or null values). </p>
<h1 id='date-column-with-status'>Date column with Status</h1>
<blockquote>
<p>Sample data</p>
</blockquote>
<div class="highlight"><pre class="highlight sql tab-sql"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="n">park_visitors</span> <span class="p">(</span>
  <span class="n">dates</span> <span class="nb">date</span> <span class="k">NOT</span>  <span class="k">NULL</span><span class="p">,</span>
  <span class="n">visitors</span> <span class="nb">integer</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">park_visitors</span> <span class="k">VALUES</span> 
<span class="p">(</span><span class="s1">'2023-03-01'</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-02'</span><span class="p">,</span> <span class="mi">109</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-03'</span><span class="p">,</span> <span class="mi">89</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-04'</span><span class="p">,</span> <span class="mi">76</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-05'</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-06'</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-07'</span><span class="p">,</span> <span class="mi">1455</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-08'</span><span class="p">,</span> <span class="mi">54</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-09'</span><span class="p">,</span> <span class="mi">98</span><span class="p">);</span>
</code></pre></div>
<p>In this version, there are 2 columns. The rows are not guaranteed to be in sequence, but is guaranteed to contain all consecutive days.</p>

<p>Table <strong>park_visitors</strong> contains 2 columns: <code>date</code>, and <code>visitors</code>. This table records the number of visitors every day, recording 0 if there are no visitors.</p>

<p>References: </p>

<ul>
<li><a href="https://towardsdatascience.com/gaps-and-islands-with-mysql-b407040d133d">Analyzing total downtime of a IoT device</a>.</li>
</ul>
<h2 id='task-objective-group-by-status-count-sequence_length'>Task objective: Group by status, count sequence_length</h2>
<blockquote>
<p>Desired output</p>
</blockquote>
<div class="highlight"><pre class="highlight markdown"><code>+------------+------------+-----------+--------+-----------------+
| start_date | end_date   | group_key | status | sequence_length |
+------------+------------+-----------+--------+-----------------+
| 2023-03-01 | 2023-03-01 |         0 |      0 |               1 |
| 2023-03-02 | 2023-03-02 |        11 |      1 |               1 |
| 2023-03-03 | 2023-03-04 |        10 |      0 |               2 |
| 2023-03-05 | 2023-03-07 |        31 |      1 |               3 |
| 2023-03-08 | 2023-03-09 |        40 |      0 |               2 |
+------------+------------+-----------+--------+-----------------+
</code></pre></div>
<p>The goal of this challenge is to find the (1) consecutive days where there are more than <100> tourist and (2) the gaps between these busy days. </p>

<p>The goal of this series of challenges is to work with a continuous stream (dates or incremental counters) and identifying <strong>islands</strong> (overlaps or consecutive rows) and <strong>gaps</strong> (missing values or null values). </p>

<aside class="success">
Note, the <strong>gaps</strong> are represented AS <code>status=0</code>.
</aside>
<h2 id='solution-rank-with-partition-by-status'>Solution: rank() with partition by status</h2><div class="highlight"><pre class="highlight sql tab-sql"><code><span class="k">WITH</span>
<span class="n">classify_into_status</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> 
    <span class="n">dates</span><span class="p">,</span> 
    <span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">visitors</span> <span class="o">&gt;=</span> <span class="mi">100</span> <span class="k">THEN</span> <span class="mi">1</span> <span class="k">ELSE</span> <span class="mi">0</span> <span class="k">END</span> <span class="k">AS</span> <span class="n">status</span>
  <span class="k">FROM</span> <span class="n">park_visitors</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">dates</span>
<span class="p">),</span>
<span class="n">sort_and_rank</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> 
    <span class="n">s</span><span class="p">.</span><span class="o">*</span><span class="p">,</span>
    <span class="n">DENSE_RANK</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">dates</span><span class="p">)</span> <span class="k">AS</span> <span class="n">rn</span><span class="p">,</span>
    <span class="n">DENSE_RANK</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">status</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">dates</span><span class="p">)</span> <span class="k">AS</span> <span class="n">rn_by_status</span>
  <span class="k">FROM</span> <span class="n">classify_into_status</span> <span class="n">s</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">dates</span>
<span class="p">),</span>
<span class="n">consecutive_dates_will_share_group_key</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> 
    <span class="n">r</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> 
    <span class="n">status</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="p">(</span><span class="n">rn</span><span class="o">-</span><span class="n">rn_by_status</span><span class="p">)</span> <span class="k">AS</span> <span class="n">group_key</span>
  <span class="k">FROM</span> <span class="n">sort_and_rank</span> <span class="n">r</span>
<span class="p">),</span>
<span class="n">final_output</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> 
    <span class="k">MIN</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span> <span class="k">AS</span> <span class="n">start_date</span><span class="p">,</span> 
    <span class="k">MAX</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span> <span class="k">AS</span> <span class="n">end_date</span><span class="p">,</span> 
    <span class="n">group_key</span><span class="p">,</span> 
    <span class="n">status</span><span class="p">,</span> 
    <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">sequence_length</span>
  <span class="k">FROM</span> <span class="n">consecutive_dates_will_share_group_key</span>
  <span class="k">WHERE</span> <span class="n">status</span> <span class="k">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">group_key</span><span class="p">,</span> <span class="n">status</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span>
<span class="p">)</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">final_output</span>
<span class="k">WHERE</span> <span class="n">sequence_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div>
<p>Go through step by step.</p>
<h3 id='classify_into_status'><code>classify_into_status</code></h3>
<p>Band the number columns into discrete statuses.</p>
<h3 id='sort_and_rank'><code>sort_and_rank</code></h3>
<p>This CTE orders the table by the <code>dates</code> column. We create an index column <code>rn</code> and a separate rank column <code>rn_by_status</code> for each status.</p>
<h3 id='consecutive_dates_will_share_group_key'><code>consecutive_dates_will_share_group_key</code></h3>
<p>Subtracting <code>rn_by_status</code> FROM <code>rn</code> will return the same <code>group_key</code> if there are consecutive rows. Because the <code>rn_by_status</code> column increments at the same pace AS the <code>rn</code> column. This allows us to have a <code>group_key</code> for each island.</p>

<aside class="notice">
There may be rare instance where the <code>group_key</code> is  duplicated across statuses. See <a href="#avoid-error-of-overalapping-groups">how to address this issue</a>.
</aside>
<h3 id='final_output'><code>final_output</code></h3>
<p>Using the <code>group_key</code>, find the min(), max(), and count().</p>
<h3 id='example-scenarios-dates-with-status'>Example scenarios: dates with status</h3>
<p>Examples include logging downtime of a system.</p>
<h1 id='single-column'>Single column</h1>
<blockquote>
<p>Sample data</p>
</blockquote>
<div class="highlight"><pre class="highlight sql tab-sql"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="n">RAINY_DAYS</span> <span class="p">(</span>
  <span class="n">dates</span> <span class="nb">date</span> <span class="k">NOT</span>  <span class="k">NULL</span>
<span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">RAINY_DAYS</span> <span class="k">VALUES</span> 
<span class="p">(</span><span class="s1">'2023-03-01'</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-03-02'</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-04-01'</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-04-05'</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-04-06'</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-04-07'</span><span class="p">),</span>
<span class="p">(</span><span class="s1">'2023-04-09'</span><span class="p">);</span>

</code></pre></div>
<p>In this version, there is only 1 column. The rows are not guaranteed to be in sequence or consecutive.</p>

<p>Table <strong>rainy_days</strong> contains 1 column: <code>date</code>. This table records if it rained every day. Days with no rain will not be reflected in the table.</p>

<p>References:</p>

<ul>
<li><a href="https://www.mssqltips.com/sqlservertutorial/9130/sql-server-window-functions-gaps-and-islands-problem/">Single column gap and island</a>.</li>
<li><a href="https://codingsight.com/similarities-and-differences-among-rank-dense_rank-and-row_number-functions/">Dense_rank vs row_number</a>.</li>
</ul>
<h2 id='task-objective-split-gap-and-island-count-sequence_length'>Task objective: Split gap and island, count sequence_length</h2>
<blockquote>
<p>Desired output</p>
</blockquote>
<div class="highlight"><pre class="highlight markdown"><code>+------------+------------+-----------------+--------+
| start_date | end_date   | sequence_length | type   |
+------------+------------+-----------------+--------+
| 2023-03-01 | 2023-03-02 |               2 | island |
| 2023-03-03 | 2023-03-31 |              29 | gap    |
| 2023-04-01 | 2023-04-01 |               1 | island |
| 2023-04-02 | 2023-04-04 |               3 | gap    |
| 2023-04-05 | 2023-04-07 |               3 | island |
| 2023-04-08 | 2023-04-08 |               1 | gap    |
| 2023-04-09 | 2023-04-09 |               1 | island |
+------------+------------+-----------------+--------+
</code></pre></div>
<p>The goal of this challenge is to find the (1) consecutive raining days and (2) the gaps between rainy days. </p>

<p>The goal of this series of challenges is to work with a continuous stream (dates or incremental counters) and identifying <strong>islands</strong> (overlaps or consecutive rows) and <strong>gaps</strong> (missing values or null values). </p>
<h2 id='solution-calculate-gaps-and-island-separately'>Solution: calculate Gaps and Island separately</h2><div class="highlight"><pre class="highlight sql tab-sql"><code><span class="k">with</span>
<span class="n">island_details</span> <span class="k">as</span> <span class="p">(</span>
  <span class="k">SELECT</span> 
    <span class="k">MIN</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">dates</span><span class="p">)</span> <span class="k">as</span> <span class="n">start_date</span><span class="p">,</span>
    <span class="k">MAX</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">dates</span><span class="p">)</span> <span class="k">as</span> <span class="n">end_date</span><span class="p">,</span>
    <span class="k">COUNT</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">dates</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">AS</span> <span class="n">sequence_length</span><span class="p">,</span>
    <span class="s1">'island'</span> <span class="k">as</span> <span class="k">type</span>
  <span class="k">FROM</span> <span class="p">(</span>
    <span class="k">SELECT</span>
      <span class="n">dates</span><span class="p">,</span>
      <span class="n">DATE_ADD</span><span class="p">(</span><span class="n">dates</span><span class="p">,</span> <span class="n">INTERVAL</span> <span class="o">-</span><span class="p">(</span><span class="n">DENSE_RANK</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">dates</span><span class="p">))</span> <span class="k">DAY</span><span class="p">)</span> <span class="k">AS</span> <span class="n">group_key</span>
    <span class="k">FROM</span> <span class="n">rainy_days</span>
  <span class="p">)</span> <span class="n">r</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">group_key</span>
<span class="p">),</span>
<span class="n">gap_details</span> <span class="k">as</span> <span class="p">(</span>
  <span class="k">SELECT</span>
    <span class="n">DATE_ADD</span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">dates</span><span class="p">,</span> <span class="n">INTERVAL</span> <span class="mi">1</span> <span class="k">DAY</span><span class="p">)</span> <span class="k">AS</span> <span class="n">start_date</span><span class="p">,</span>
    <span class="n">DATE_ADD</span><span class="p">(</span><span class="k">MIN</span><span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">dates</span><span class="p">),</span> <span class="n">INTERVAL</span> <span class="o">-</span><span class="mi">1</span> <span class="k">DAY</span><span class="p">)</span> <span class="k">AS</span> <span class="n">end_date</span><span class="p">,</span>
    <span class="n">DATEDIFF</span><span class="p">(</span><span class="k">MIN</span><span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">dates</span><span class="p">),</span> <span class="n">t1</span><span class="p">.</span><span class="n">dates</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">AS</span> <span class="n">sequence_length</span><span class="p">,</span>
    <span class="s1">'gap'</span> <span class="k">AS</span> <span class="k">type</span>
  <span class="k">FROM</span> <span class="n">rainy_days</span> <span class="n">t1</span>
  <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">rainy_days</span> <span class="n">t2</span> <span class="k">ON</span> <span class="n">t2</span><span class="p">.</span><span class="n">dates</span> <span class="o">&gt;</span> <span class="n">t1</span><span class="p">.</span><span class="n">dates</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">t1</span><span class="p">.</span><span class="n">dates</span>
  <span class="k">HAVING</span> <span class="n">DATEDIFF</span><span class="p">(</span><span class="k">MIN</span><span class="p">(</span><span class="n">t2</span><span class="p">.</span><span class="n">dates</span><span class="p">),</span> <span class="n">t1</span><span class="p">.</span><span class="n">dates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
<span class="p">),</span>
<span class="n">final_output</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">ISLAND_DETAILS</span>
  <span class="k">UNION</span> <span class="k">ALL</span>
  <span class="k">SElecT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">GAP_DETAILS</span>
<span class="p">)</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">final_output</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="p">;</span>
</code></pre></div>
<p>The process to get the gaps and islands are distinct as there is not reliable consecutive index column.</p>

<p>Instead, we will calculate them separately and combine them afterwards.</p>
<h3 id='island_details'><code>island_details</code></h3>
<p>This solution requires us to how consecutive data points work in conjunction with the <code>DENSE_RANK()</code> function. When consecutive data points (e.g. consecutive dates) increment step by step with the index column <code>rn</code>, it returns a unique <code>group_key</code> for that series of consecutive rows.</p>

<p>Next, we calculate MIN(), MAX(), and count() of each <code>group_key</code> which gives us the <code>start_date</code>, <code>end_date</code>, and <code>sequence_length</code>.</p>
<h3 id='gap_details'><code>gap_details</code></h3>
<p>Explanation</p>
<h3 id='final_output'><code>final_output</code></h3>
<p>To present the results in sequence, we combine the <code>island_details</code> and <code>gap_details</code> using the <code>union</code> operator.</p>
<h1 id='range-with-status'>Range with status</h1>
<blockquote>
<p>Sample data</p>
</blockquote>
<div class="highlight"><pre class="highlight sql tab-sql"><code><span class="k">DROP</span> <span class="k">TABLE</span> <span class="n">library_books</span><span class="p">;</span>
<span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">IF</span> <span class="k">NOT</span> <span class="k">EXISTS</span> <span class="n">library_books</span> <span class="p">(</span>
  <span class="n">borrower</span> <span class="nb">integer</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">book_id</span> <span class="nb">integer</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="n">checkout_date</span> <span class="nb">date</span> <span class="k">NOT</span>  <span class="k">NULL</span><span class="p">,</span>
  <span class="n">return_date</span> <span class="nb">date</span> <span class="k">NOT</span>  <span class="k">NULL</span>
<span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">library_books</span> <span class="k">VALUES</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">03</span><span class="p">,</span> <span class="s1">'2023-03-01'</span><span class="p">,</span> <span class="s1">'2023-03-03'</span><span class="p">),</span> 
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">01</span><span class="p">,</span> <span class="s1">'2023-03-01'</span><span class="p">,</span> <span class="s1">'2023-03-03'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">02</span><span class="p">,</span> <span class="s1">'2023-03-02'</span><span class="p">,</span> <span class="s1">'2023-03-03'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">04</span><span class="p">,</span> <span class="s1">'2023-03-02'</span><span class="p">,</span> <span class="s1">'2023-03-04'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">02</span><span class="p">,</span> <span class="s1">'2023-03-03'</span><span class="p">,</span> <span class="s1">'2023-03-06'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">03</span><span class="p">,</span> <span class="s1">'2023-03-04'</span><span class="p">,</span> <span class="s1">'2023-03-04'</span><span class="p">),</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">01</span><span class="p">,</span> <span class="s1">'2023-03-09'</span><span class="p">,</span> <span class="s1">'2023-03-10'</span><span class="p">);</span>
</code></pre></div>
<p>In this version, there are 2 columns that signify the range, and more columns to describe unique attributes like groups or product ID. The ranges are not guaranteed to be in sequence, mutually exclusive, or does it cover the entire range. </p>

<p>Table <strong>library_rentals</strong> contains 4 columns: <code>borrower</code>, <code>book_id</code>,<code>checkout_date</code>, and <code>return_date</code>. They record which book was borrowed and for how long.</p>

<p>For example, ranges [(1,6),(2,5),(3,4)] should return (1,6).</p>

<p>References:</p>

<ul>
<li><a href="https://medium.com/analytics-vidhya/sql-classic-problem-identifying-gaps-and-islands-across-overlapping-date-ranges-5681b5fcdb8">Resolving overlapping ranges</a></li>
<li><a href="https://peterevans.dev/posts/gaps-and-islands-merging-contiguous-ranges/">Merging contiguous ranges</a>.</li>
</ul>
<h2 id='task-objective-group-ranges-that-overlap'>Task objective: Group ranges that overlap</h2>
<blockquote>
<p>Desired output</p>
</blockquote>
<div class="highlight"><pre class="highlight plaintext"><code>+------------+------------+-----------+-----------+-----------------+
| start_date | end_date   | group_key | num_books | sequence_length |
+------------+------------+-----------+-----------+-----------------+
| 2023-03-01 | 2023-03-05 |        11 |         2 |               4 |
| 2023-03-01 | 2023-03-06 |        12 |         3 |               5 |
| 2023-03-09 | 2023-03-10 |        21 |         1 |               1 |
+------------+------------+-----------+-----------+-----------------+
</code></pre></div>
<p>The goal of this challenge is to find the (1) overlapping range and report the the earliest and latest data points, group by borrower, ignoring the book_id and (2) the gaps where no books where borrowed.</p>
<h2 id='solution'>Solution</h2><div class="highlight"><pre class="highlight sql tab-sql"><code><span class="k">with</span>
<span class="n">last_return_date</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> <span class="n">borrower</span><span class="p">,</span> <span class="n">book_id</span><span class="p">,</span> <span class="n">checkout_date</span><span class="p">,</span> <span class="n">return_date</span><span class="p">,</span>
    <span class="n">DENSE_RANK</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">checkout_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">rn</span><span class="p">,</span>
    <span class="k">MAX</span><span class="p">(</span><span class="n">return_date</span><span class="p">)</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">borrower</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">checkout_date</span><span class="p">,</span> <span class="n">return_date</span> <span class="k">ROWS</span> <span class="k">BETWEEN</span> <span class="n">UNBOUNDED</span> <span class="k">PRECEDING</span> <span class="k">AND</span> <span class="mi">1</span> <span class="k">PRECEDING</span><span class="p">)</span> <span class="k">AS</span> <span class="n">last_return_date</span>
  <span class="k">FROM</span> <span class="n">library_books</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">checkout_date</span><span class="p">,</span> <span class="n">return_date</span>
<span class="p">),</span>
<span class="n">start_of_island</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> <span class="n">l</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">checkout_date</span> <span class="o">&lt;=</span> <span class="n">last_return_date</span> <span class="k">THEN</span> <span class="mi">0</span> <span class="k">ELSE</span> <span class="mi">1</span> <span class="k">END</span> <span class="k">AS</span> <span class="n">is_start</span>
  <span class="k">FROM</span> <span class="n">last_return_date</span> <span class="n">l</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">checkout_date</span><span class="p">,</span> <span class="n">return_date</span>
<span class="p">),</span>
<span class="n">islands_will_share_group_key</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> <span class="n">s</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="n">borrower</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="k">SUM</span><span class="p">(</span><span class="n">is_start</span><span class="p">)</span> <span class="n">OVER</span> <span class="p">(</span> <span class="k">PARTITION</span> <span class="k">BY</span> <span class="n">borrower</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">checkout_date</span><span class="p">,</span> <span class="n">return_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">group_key</span>
  <span class="k">FROM</span> <span class="n">start_of_island</span> <span class="n">s</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">checkout_date</span><span class="p">,</span> <span class="n">return_date</span>
<span class="p">),</span>
<span class="n">consolidated_range_for_each_group</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> <span class="k">MIN</span><span class="p">(</span><span class="n">checkout_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">start_date</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="n">return_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">end_date</span><span class="p">,</span> <span class="n">group_key</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="n">book_id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">num_books</span><span class="p">,</span> <span class="n">datediff</span><span class="p">(</span><span class="k">MAX</span><span class="p">(</span><span class="n">return_date</span><span class="p">),</span><span class="k">MIN</span><span class="p">(</span><span class="n">checkout_date</span><span class="p">))</span> <span class="k">AS</span> <span class="n">sequence_length</span>
  <span class="k">FROM</span> <span class="n">islands_will_share_group_key</span>
  <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">group_key</span>
  <span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span>
<span class="p">)</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">consolidated_range_for_each_group</span><span class="p">;</span>
</code></pre></div>
<p>Go through step by step.</p>
<h3 id='last_return_date'><code>last_return_date</code></h3>
<p>The first step is to order all event by <code>checkout_date</code> and <code>return_date</code>. For each row, find the most recent <code>return_date</code> (<code>last_return_date</code>). This allow us to check if the end points of the range is extended by an earlier row.</p>
<h3 id='start_of_island-as'><code>start_of_island as (</code></h3>
<p>This checks if there is a consecutive streak from the <code>last_return_date</code>. If not, this signifies that there is a new <strong>island</strong>.</p>
<h3 id='islands_will_share_group_key'><code>islands_will_share_group_key</code></h3>
<p>Using the <code>SUM()</code> window function, the <code>group_key</code> counts all the exclusive new islands of the group - partitioned by unique attributes like user_id or borrower.</p>

<aside class="notice">
There may be rare instance where the <code>group_key</code> is  duplicated across statuses. See <a href="#avoid-error-of-overalapping-groups">how to address this issue</a>.
</aside>
<h3 id='consolidated_range_for_each_group'><code>consolidated_range_for_each_group</code></h3>
<p>Finally, use the group_key to find the min(), max(), and count(). This will merge and reduce the initial ranges to distinct ranges with overlaps. Each range will specific the unique identified (e.g. user_id, borrower).</p>
<h1 id='avoid-error-of-overalapping-groups'>Avoid error of overalapping groups</h1><div class="highlight"><pre class="highlight plaintext"><code>+------------+----+--------------+-----------+--------+-------------------+
| dates      | rn | rn_by_status | group_key |  status |correct_group_key |
+------------+----+--------------+-----------+--------+-------------------+
| 2023-03-01 |  1 |            1 |         0 |      0 |                 0 |
| 2023-03-02 |  2 | ---------- 1 | ------- 1 | ---- 1 | -------------- 11 |
| 2023-03-03 |  3 | ---------- 2 | ------- 1 | ---- 0 | -------------- 10 |
| 2023-03-04 |  4 | ---------- 3 | ------- 1 | ---- 0 | -------------- 10 |
| 2023-03-05 |  5 |            2 |         3 |      1 |                31 |
| 2023-03-06 |  6 |            3 |         3 |      1 |                31 |
| 2023-03-07 |  7 |            4 |         3 |      1 |                31 |
| 2023-03-08 |  8 |            4 |         4 |      0 |                40 |
| 2023-03-09 |  9 |            5 |         4 |      0 |                40 |
+------------+----+--------------+-----------+--------+-------------------+
</code></pre></div>
<p>By subtracting <code>rn_by_status</code> from <code>rn</code>, the <code>group_key</code> should belong in the same grouping only if they are consecutive and belong to the same status (at least that is what you want if there were no bug). In other words, by using PARTITION BY status, the rankings are incremented for each status; this creates the incremental offset that we need so that when ranking is subtracted from id, we get our desired groupings.</p>

<p>But by chance, the order of the data may cause overlapping <code>group_keys</code>.</p>
<h2 id='best-practice-to-avoid-duplicate-group_keys'>Best practice to avoid duplicate group_keys</h2><div class="highlight"><pre class="highlight sql tab-sql"><code><span class="n">status</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="p">(...)</span> <span class="k">AS</span> <span class="n">group_key</span>
</code></pre></div>
<p>To fix this, append the status column to your <code>correct_group_key</code>. Eeliang suggest adding the main identifier (<code>status</code> or <code>user_id</code>) in the ones place. This ensures that we always know where to identify the status.</p>

<p>References:</p>

<ul>
<li><a href="https://binhhoang.io/blog/gaps-and-islands/">Resolving duplicate group_keys</a></li>
</ul>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="sql">sql</a>
                <a href="#" data-language-name="markdown">markdown</a>
          </div>
      </div>
    </div>
  </body>
</html>
